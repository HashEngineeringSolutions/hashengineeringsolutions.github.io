<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Coding conventions in bitcoinj</title>
<link rel="icon" type="image/png" href="/favicon16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicon32.png" sizes="32x32">
<link rel="stylesheet" type="text/css" href="/css/main.css" />
<script type="text/javascript" src="/js/main.js"></script>
</head>
<body>

<div class="headercontainer"><div class="header">
<a href="/" class="logo"><img src="/img/bitcoinjlogo.svg"></a>
<ul class="menu" id="menu">
  <li><a href="/#introduction">Introduction</a></li>
  <li><a href="/#getting-started">Getting started</a></li>
  <li><a href="/#documentation">Documentation</a></li>
  <li><a href="/#community">Community</a></li>
</ul>
</div></div>

<div class="content">
  <div id="toc" class="toc">
  <div>

<ul id="markdown-toc">
  <li><a href="#coding-style">Coding style</a></li>
  <li><a href="#comments">Comments</a></li>
  <li><a href="#threading">Threading</a></li>
  <li><a href="#static-analysis">Static analysis</a></li>
  <li><a href="#assertions">Assertions</a></li>
  <li><a href="#java">Java</a></li>
</ul>

  </div>
</div>

<div class="toccontent">

  <h1 id="coding-conventions-in-bitcoinj">Coding conventions in bitcoinj</h1>

  <p>This article discusses various conventions and style rules that bitcoinj uses. If you want to contribute to the project, please read and understand this document first.</p>

  <h2 id="coding-style">Coding style</h2>

  <p>We use the standard coding style from Sun, but pay attention to the following rules:</p>

  <p>Code is vertically dense, blank lines in methods are used sparingly. This is so more code can fit on screen at once.</p>

  <p>We try to avoid lines going beyond 120 columns. However this is not a hard and fast rule. Content that is typically not very important like throws declarations are allowed to spill over if it results in more vertically dense code. Logic and comments should fit though.</p>

  <p>Each file has a copyright notice at the top. You should put your own name there, unless you work for Google, in which case please put Google’s name there instead. We do not mark classes with @author annotations, we have an AUTHORS file in the top level instead.</p>

  <h2 id="comments">Comments</h2>

  <p>We like them as long as they add detail that is missing from the code. Comments that simply repeat the story already told by the code are best deleted. Comments should:</p>

  <ul>
    <li>Explain <strong>what</strong> the code is doing at a higher level than is obtainable from just examining the statement and surrounding code.</li>
    <li>Explain <strong>why</strong> certain choices were made and the tradeoffs considered.</li>
    <li>Don’t be afraid of <strong>redundancy</strong>, many people will start reading your code in the middle with little or no idea of what it’s about, eg, due to a bug or a need to introduce a new feature. It’s OK to repeat basic facts or descriptions in different places if that increases the chance developers will see something important.</li>
    <li>Explain <strong>how things can go wrong</strong>, which is a detail often not easily seen just by reading the code.</li>
    <li>Use good grammar with capital letters and full stops. This gets us in the right frame of mind for writing real explanations of things.</li>
  </ul>

  <p>JavaDocs: all public methods, constants and classes should have JavaDocs. JavaDocs should:</p>

  <ul>
    <li>Explain what the method does <strong>in words different to how the code describes it</strong></li>
    <li>Always have some text, annotation-only JavaDocs don’t render well. Write “Returns a blah blah blah” rather than “@returns blah blah blah”.</li>
    <li>Illustrate with examples when you might want to use the method or class. Point the user at alternatives if this code is not always right.</li>
    <li>Make good use of {@link} annotations.</li>
  </ul>

  <p>Bad JavaDocs look like this:</p>

  <div class="highlight"><pre><code class="java">   <span class="cm">/** @return the size of the Bloom filter. */</span>
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getBloomFilterSize</span><span class="o">()</span> <span class="o">{</span>
       <span class="k">return</span> <span class="n">block</span><span class="o">;</span>
   <span class="o">}</span>
</code></pre></div>

  <p>Good JavaDocs look like this:</p>

  <div class="highlight"><pre><code class="java">   <span class="cm">/**</span>
<span class="cm">    * Returns the size of the current {@link BloomFilter} in bytes. Larger filters have </span>
<span class="cm">    * lower false positive rates for the same number of inserted keys and thus lower privacy, </span>
<span class="cm">    * but bandwidth usage is also correspondingly reduced.</span>
<span class="cm">    */</span>
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getBloomFilterSize</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div>

  <h2 id="threading">Threading</h2>

  <p>All bitcoinj code is thread safe by default, exceptions are marked. Objects that have event listeners should allow users to specify an executor and then use it. If no executor is specified then <code>Threading.USER_THREAD</code> should be used, this is an executor that marshals runnables onto a background thread. Sometimes library internal event handlers can use <code>Threading.SAME_THREAD</code> however they must be written carefully to avoid lock inversions.</p>

  <p>Event listeners are stored using CopyOnWriteArrayLists so they can be modified concurrently with execution (when they run in the same thread), in particular, this means that listeners can add or remove more listeners during their own execution without problems. We use Guava cycle detecting locks to find cases where locks get accidentally inverted, which is almost always due to chains of event listeners. Prefer <code>Threading.lock</code> to the use of synchronized statements where possible.</p>

  <p>We make use of volatile variables for references and booleans. For integers we use AtomicInteger. Variables that can be accessed by multiple threads should be marked as volatile and named with a v prefix, ie “thingiesPerSecond” becomes “vThingiesPerSecond”. This is so when you read the bodies of methods that are thread safe, you can quickly spot class member variables that are not volatile.</p>

  <h2 id="static-analysis">Static analysis</h2>

  <p>We like IntelliJ Inspector. It can find similar bugs to FindBugs but with the advantage that it runs constantly in the background and seems to support a wider range of issues. We use annotations like <code>@GuardedBy</code> to help detect cases where variables aren’t being properly locked, although the inspection for that isn’t perfect by any means. We also use <code>@Override</code> and <code>@VisibleForTesting</code>.</p>

  <p>We use nullity annotations. Field members and method parameters are assumed to not contain null by default, and cases where they can are marked with <code>@Nullable</code>. This allows static analysis engines like the Inspector to flag cases where we’re possibly dereferencing a null pointer.</p>

  <h2 id="assertions">Assertions</h2>

  <p>We don’t use the Java assert keyword, we use the Guava Preconditions class instead. The reason is that enabling assertions on Dalvik is a bit annoying and they are typically disabled in the field. However, we want assertions to always be enabled, even in production, because they are sometimes checking security sensitive matters.</p>

  <p>We statically import Preconditions whenever it’s used, so we can write code like this:</p>

  <div class="highlight"><pre><code class="java"><span class="n">checkState</span><span class="o">(</span><span class="n">foo</span><span class="o">,</span> <span class="s">&quot;Object is not in the right state&quot;</span><span class="o">);</span>
<span class="n">checkArgument</span><span class="o">(</span><span class="n">widget</span><span class="o">.</span><span class="na">isActive</span><span class="o">(),</span> <span class="s">&quot;This method requires an active widget&quot;</span><span class="o">);</span>
<span class="n">Bar</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">checkNotNull</span><span class="o">(</span><span class="n">foo</span><span class="o">.</span><span class="na">bar</span><span class="o">);</span>
</code></pre></div>

  <p>You will see checkNotNull not only verifying arguments but used in other places too. This is typically done in order to prove to IntelliJ Inspector that a variable cannot be null at that point in time due to complex logic it can’t figure out by itself (it knows how to read if statements in the same method and similar). This allows us to clear static analysis warnings that would otherwise flag a possible nullity violation.</p>

  <h2 id="java">Java</h2>

  <p>We target Java 6. This is because that’s the version supported by Android phones. Due to our desire to make Bitcoin universally usable, we want to support developing countries where even new phones ship with Gingerbread for cost reasons. Therefore it will be a long time until we can use any JDK7 features that require runtime support, as Java 7 started being supported only with Android KitKat. Fortunately smart IDE’s can take away most of the painful parts of working with Java 6.</p>

  <p>We make minimal use of fancy tricks like code synthesis or reflection. Thus we also avoid frameworks that rely on them too. One reason is to keep things simple and readable, another reason is to avoid closing doors to things like trans-compilation into other languages or aggressive dead code elimination.</p>

</div>

</div>
</body>

<script>fallbackSVG();</script>
<script>updateToc();</script>

</html>
