<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Working with contracts</title>
<link rel="icon" type="image/png" href="/favicon16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicon32.png" sizes="32x32">
<link rel="stylesheet" type="text/css" href="/css/main.css" />
<script type="text/javascript" src="/js/main.js"></script>
</head>
<body>

<div class="headercontainer"><div class="header">
<a href="/" class="logo"><img src="/img/bitcoinjlogo.svg"></a>
<ul class="menu" id="menu">
  <li><a href="/#introduction">Introduction</a></li>
  <li><a href="/#getting-started">Getting started</a></li>
  <li><a href="/#documentation">Documentation</a></li>
  <li><a href="/#community">Community</a></li>
</ul>
</div></div>

<div class="content">
  <div id="toc" class="toc">
  <div>

<ul id="markdown-toc">
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#creating-multi-signature-outputs">Creating multi-signature outputs</a></li>
  <li><a href="#partial-signing">Partial signing</a></li>
  <li><a href="#other-sighash-modes">Other SIGHASH modes</a></li>
</ul>

  </div>
</div>

<div class="toccontent">

  <h1 id="working-with-contracts">Working with contracts</h1>

  <p><em>How to design and implement contract based applications.</em></p>

  <h2 id="introduction">Introduction</h2>

  <p><a href="https://en.bitcoin.it/wiki/Contracts">Contracts</a> are an exciting feature of Bitcoin that has opened up a new research field - using flexible digital money to produce compelling and innovative applications. The linked wiki page contains some examples of what can be done, but it can sometimes be unclear how to convert them into code.</p>

  <p>In this article, we’ll look at a few common techniques that are used when implementing contract-based applications. It assumes you’re already familiar with how the Bitcoin protocol works and have understood the theory on the contracts page - if something is unclear, please ask on the mailing list.</p>

  <h2 id="creating-multi-signature-outputs">Creating multi-signature outputs</h2>

  <p>Contracts very often use multi-signature outputs in order to allocate value to a group of users … typically, the participants in the contract protocol. Multi-signature outputs are easy to create with bitcoinj. Let’s see how to do it:</p>

  <div class="highlight"><pre><code class="java"><span class="c1">// Create a random key.</span>
<span class="n">ECKey</span> <span class="n">clientKey</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ECKey</span><span class="o">();</span>
<span class="c1">// We get the other parties public key from somewhere ...</span>
<span class="n">ECKey</span> <span class="n">serverKey</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ECKey</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">publicKeyBytes</span><span class="o">);</span>

<span class="c1">// Prepare a template for the contract.</span>
<span class="n">Transaction</span> <span class="n">contract</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Transaction</span><span class="o">(</span><span class="n">params</span><span class="o">);</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">ECKey</span><span class="o">&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">clientKey</span><span class="o">,</span> <span class="n">serverKey</span><span class="o">);</span>
<span class="c1">// Create a 2-of-2 multisig output script.</span>
<span class="n">Script</span> <span class="n">script</span> <span class="o">=</span> <span class="n">ScriptBuilder</span><span class="o">.</span><span class="na">createMultiSigOutputScript</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">keys</span><span class="o">);</span>
<span class="c1">// Now add an output for 0.50 bitcoins that uses that script.</span>
<span class="n">BigInteger</span> <span class="n">amount</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="na">toNanoCoins</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">50</span><span class="o">);</span>
<span class="n">contract</span><span class="o">.</span><span class="na">addOutput</span><span class="o">(</span><span class="n">amount</span><span class="o">,</span> <span class="n">script</span><span class="o">);</span>

<span class="c1">// We have said we want to make 0.5 coins controlled by us and them.</span>
<span class="c1">// But it&#39;s not a valid tx yet because there are no inputs.</span>
<span class="n">Wallet</span><span class="o">.</span><span class="na">SendRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="n">Wallet</span><span class="o">.</span><span class="na">SendRequest</span><span class="o">.</span><span class="na">forTx</span><span class="o">(</span><span class="n">contract</span><span class="o">);</span>
<span class="n">wallet</span><span class="o">.</span><span class="na">completeTx</span><span class="o">(</span><span class="n">req</span><span class="o">);</span>   <span class="c1">// Could throw InsufficientMoneyException</span>

<span class="c1">// Broadcast and wait for it to propagate across the network.</span>
<span class="c1">// It should take a few seconds unless something went wrong.</span>
<span class="n">peerGroup</span><span class="o">.</span><span class="na">broadcastTransaction</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">tx</span><span class="o">).</span><span class="na">get</span><span class="o">();</span>
</code></pre></div>

  <p>Alright, now we have broadcast the transaction - note that in some contract protocols, you don’t actually broadcast right away. The example above just does it for completeness.</p>

  <p>But how do we get the money back again? For that, we need a transaction that includes two signatures, one calculated by us, and one by them.</p>

  <h2 id="partial-signing">Partial signing</h2>

  <p>A common requirement when implementing contract protocols is to pass around and sign incomplete transactions.</p>

  <p>The <code>Wallet</code> class doesn’t know how to handle outputs that aren’t fully owned by it. So we’ll have to sign the spending transaction ourselves.</p>

  <p>The key point to bear in mind is that when you sign a transaction, what you actually sign is only parts of that transaction. Which parts are controlled by the signature hash (sighash) flags. But no matter which flags you select, the contents of input scripts are never signed. Indeed that must be the case, because otherwise you could never build a transaction - the act of signing the second input would modify the version of the transaction signed by the first, breaking the signature.</p>

  <p>This means that signatures can be calculated and sent between different parties in a contract, then inserted into a transaction to make it valid.</p>

  <p>Let’s look at what the server-side code might look like:</p>

  <div class="highlight"><pre><code class="java"><span class="c1">// Assume we get the multisig transaction we&#39;re trying to spend from </span>
<span class="c1">// somewhere, like a network connection.</span>
<span class="n">ECKey</span> <span class="n">serverKey</span> <span class="o">=</span> <span class="o">....;</span>
<span class="n">Transaction</span> <span class="n">contract</span> <span class="o">=</span> <span class="o">....;</span>
<span class="n">TransactionOutput</span> <span class="n">multisigOutput</span> <span class="o">=</span> <span class="n">contract</span><span class="o">.</span><span class="na">getOutput</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">Script</span> <span class="n">multisigScript</span> <span class="o">=</span> <span class="n">multisigOutput</span><span class="o">.</span><span class="na">getScriptPubKey</span><span class="o">();</span>
<span class="c1">// Is the output what we expect?</span>
<span class="n">checkState</span><span class="o">(</span><span class="n">multisigScript</span><span class="o">.</span><span class="na">isSentToMultiSig</span><span class="o">());</span>
<span class="n">BigInteger</span> <span class="n">value</span> <span class="o">=</span> <span class="n">multisigOutput</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>

<span class="c1">// OK, now build a transaction that spends the money back to the client.</span>
<span class="n">Transaction</span> <span class="n">spendTx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Transaction</span><span class="o">(</span><span class="n">params</span><span class="o">);</span>
<span class="n">spendTx</span><span class="o">.</span><span class="na">addOutput</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">clientKey</span><span class="o">);</span>
<span class="n">spendTx</span><span class="o">.</span><span class="na">addInput</span><span class="o">(</span><span class="n">multisigOutput</span><span class="o">);</span>

<span class="c1">// It&#39;s of the right form. But the wallet can&#39;t sign it. So, we have to</span>
<span class="c1">// do it ourselves.</span>
<span class="n">Sha256Hash</span> <span class="n">sighash</span> <span class="o">=</span> <span class="n">spendTx</span><span class="o">.</span><span class="na">hashTransactionForSignature</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">multisigScript</span><span class="o">,</span> <span class="n">Transaction</span><span class="o">.</span><span class="na">SIGHASH_ALL</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="n">ECKey</span><span class="o">.</span><span class="na">ECDSASignature</span> <span class="n">signature</span> <span class="o">=</span> <span class="n">serverKey</span><span class="o">.</span><span class="na">sign</span><span class="o">(</span><span class="n">sighash</span><span class="o">);</span>
<span class="c1">// We have calculated a valid signature, so send it back to the client:</span>
<span class="n">sendToClientApp</span><span class="o">(</span><span class="n">signature</span><span class="o">);</span>
</code></pre></div>

  <p>The server receives the contract and decides to give all the money back to the client (how generous of it!). It constructs a transaction and signs it. Now the client must repeat the process and construct exactly the same transaction and calculate a signature in the same way. It is then in possession of two valid signatures over the same transaction, one from itself and one from the server. All that is left is to put them both into the transaction:</p>

  <div class="highlight"><pre><code class="java"><span class="n">TransactionOutput</span> <span class="n">multisigContract</span> <span class="o">=</span> <span class="o">....;</span>
<span class="n">ECKey</span><span class="o">.</span><span class="na">ECSDASignature</span> <span class="n">serverSignature</span> <span class="o">=</span> <span class="o">....;</span>

<span class="c1">// Client side code.</span>
<span class="n">Transaction</span> <span class="n">spendTx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Transaction</span><span class="o">(</span><span class="n">params</span><span class="o">);</span>
<span class="n">spendTx</span><span class="o">.</span><span class="na">addOutput</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">clientKey</span><span class="o">);</span>
<span class="n">TransactionInput</span> <span class="n">input</span> <span class="o">=</span> <span class="n">spendTx</span><span class="o">.</span><span class="na">addInput</span><span class="o">(</span><span class="n">multisigOutput</span><span class="o">);</span>
<span class="n">Sha256Hash</span> <span class="n">sighash</span> <span class="o">=</span> <span class="n">spendTx</span><span class="o">.</span><span class="na">hashTransactionForSignature</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">multisigScript</span><span class="o">,</span> <span class="n">Transaction</span><span class="o">.</span><span class="na">SIGHASH_ALL</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="n">ECKey</span><span class="o">.</span><span class="na">ECDSASignature</span> <span class="n">mySignature</span> <span class="o">=</span> <span class="n">clientKey</span><span class="o">.</span><span class="na">sign</span><span class="o">(</span><span class="n">sighash</span><span class="o">);</span>

<span class="c1">// Create the script that spends the multi-sig output.</span>
<span class="n">Script</span> <span class="n">inputScript</span> <span class="o">=</span> <span class="n">ScriptBuilder</span><span class="o">.</span><span class="na">createMultiSigInputScript</span><span class="o">(</span>
    <span class="n">ImmutableList</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">mySignature</span><span class="o">,</span> <span class="n">serverSignature</span><span class="o">),</span> <span class="n">Transaction</span><span class="o">.</span><span class="na">SIGHASH_ALL</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="c1">// Add it to the input.</span>
<span class="n">input</span><span class="o">.</span><span class="na">setScriptSig</span><span class="o">(</span><span class="n">inputScript</span><span class="o">);</span>

<span class="c1">// We can now check the server provided signature is correct, of course...</span>
<span class="n">input</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">multisigOutput</span><span class="o">);</span>  <span class="c1">// Throws an exception if the script doesn&#39;t run.</span>

<span class="c1">// It&#39;s valid! Let&#39;s take back the money.</span>
<span class="n">peerGroup</span><span class="o">.</span><span class="na">broadcastTransaction</span><span class="o">(</span><span class="n">spendTx</span><span class="o">).</span><span class="na">get</span><span class="o">();</span>
<span class="c1">// Wallet now has the money back in it.</span>
</code></pre></div>

  <p>As you can see, the process involves building a transaction that spends the first one, calculating a signature and then manually building the script that can spend the multi-signature output. Once we’ve built it, we use <code>verify()</code> to ensure the script we wrote satisfies the multisig output correct, and thus that the other side didn’t hand us a garbage signature.</p>

  <h2 id="other-sighash-modes">Other SIGHASH modes</h2>

  <p>You can specify alternative SIGHASH modes to control what is signed and how the other parties can modify the transaction without breaking your signature. These modes are documented on the contracts page linked to above. However, please note that the API for this is likely to change a bit in future.</p>

</div>

</div>
</body>

<script>fallbackSVG();</script>
<script>updateToc();</script>

</html>
